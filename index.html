<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juego de Esquivar Obstáculos</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #222;
            color: #fff;
            font-family: 'Press Start 2P', cursive, Arial, sans-serif;
            overflow: hidden;
            flex-direction: column;
            text-align: center;
        }
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        canvas {
            background-color: #000;
            border: 2px solid #fff;
            touch-action: none;
        }
        #game-info {
            display: flex;
            justify-content: space-between;
            width: 90%;
            max-width: 400px;
            margin-top: 10px;
            font-size: 14px;
        }
        .info-item {
            padding: 5px 10px;
            background-color: #444;
            border-radius: 5px;
        }
        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        #game-over-screen h2 {
            font-size: 2em;
            margin-bottom: 10px;
        }
        .action-button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            background-color: #007BFF;
            color: #fff;
            border-radius: 5px;
            margin-top: 10px;
            font-family: 'Press Start 2P', cursive, Arial, sans-serif;
            text-decoration: none;
        }
        #navigation-bar {
            margin-top: 20px;
            padding: 10px;
            background-color: #333;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 15px;
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <h1>Juego de Esquivar</h1>
    <div id="game-info">
        <div class="info-item">Vidas: <span id="lives-display"></span></div>
        <div class="info-item">Tiempo: <span id="timer-display">0s</span></div>
    </div>
    <canvas id="gameCanvas"></canvas>
    
    <div id="game-over-screen">
        <h2>¡Fin del Juego!</h2>
        <p>Tiempo de juego: <span id="final-time">0s</span></p>
        <button id="restart-button" class="action-button">Reiniciar</button>
    </div>

    <div id="navigation-bar">
        <a href="snake.html" class="action-button">Serpiente</a>
        <a href="rompe-ladrillos.html" class="action-button">Rompe-Ladrillos</a>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const livesDisplay = document.getElementById('lives-display');
        const timerDisplay = document.getElementById('timer-display');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalTimeDisplay = document.getElementById('final-time');
        const restartButton = document.getElementById('restart-button');

        function setCanvasSize() {
            canvas.width = Math.min(window.innerWidth * 0.9, 400);
            canvas.height = Math.min(window.innerHeight * 0.7, 600);
        }
        setCanvasSize();
        window.addEventListener('resize', setCanvasSize);

        let player, obstacles, lives, gameTime, isGameOver, dx, obstacleInterval, timerInterval;

        const playerOptions = {
            x: 0,
            y: 0,
            width: 20,
            height: 20,
            color: 'skyblue',
            speed: 5
        };

        const obstacleShapes = ['square', 'circle', 'triangle'];
        const obstacleColors = ['red', 'orange', 'yellow', 'lime', 'cyan', 'magenta'];

        function resetGame() {
            player = {
                ...playerOptions,
                x: canvas.width / 2,
                y: canvas.height - playerOptions.height - 10
            };
            obstacles = [];
            lives = 3;
            gameTime = 0;
            isGameOver = false;
            dx = 0;

            gameOverScreen.style.display = 'none';
            updateLivesDisplay();
            timerDisplay.textContent = `${gameTime}s`;
            
            clearInterval(obstacleInterval);
            clearInterval(timerInterval);

            obstacleInterval = setInterval(createObstacle, 1000);
            timerInterval = setInterval(() => {
                if (!isGameOver) {
                    gameTime++;
                    timerDisplay.textContent = `${gameTime}s`;
                }
            }, 1000);
            
            gameLoop();
        }

        function updateLivesDisplay() {
            livesDisplay.innerHTML = '';
            for (let i = 0; i < lives; i++) {
                const heart = document.createElement('span');
                heart.classList.add('heart');
                heart.textContent = '❤';
                livesDisplay.appendChild(heart);
            }
        }
        
        function drawPlayer() {
            ctx.fillStyle = player.color;
            ctx.fillRect(player.x, player.y, player.width, player.height);
        }

        function createObstacle() {
            const size = 20 + Math.random() * 15;
            const x = Math.random() * (canvas.width - size);
            const y = -size;
            const speed = 2 + Math.random() * 3;
            const shape = obstacleShapes[Math.floor(Math.random() * obstacleShapes.length)];
            const color = obstacleColors[Math.floor(Math.random() * obstacleColors.length)];
            obstacles.push({ x, y, width: size, height: size, speed, shape, color });
        }

        function drawObstacles() {
            obstacles.forEach(obs => {
                ctx.fillStyle = obs.color;
                if (obs.shape === 'square') {
                    ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                } else if (obs.shape === 'circle') {
                    ctx.beginPath();
                    ctx.arc(obs.x + obs.width / 2, obs.y + obs.height / 2, obs.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();
                } else if (obs.shape === 'triangle') {
                    ctx.beginPath();
                    ctx.moveTo(obs.x + obs.width / 2, obs.y);
                    ctx.lineTo(obs.x, obs.y + obs.height);
                    ctx.lineTo(obs.x + obs.width, obs.y + obs.height);
                    ctx.fill();
                    ctx.closePath();
                }
            });
        }

        function updateObstacles() {
            obstacles.forEach(obs => {
                obs.y += obs.speed;
            });
            obstacles = obstacles.filter(obs => obs.y < canvas.height);
        }

        function checkCollision() {
            let collisionOccurred = false;
            obstacles.forEach((obs, index) => {
                const playerCenterX = player.x + player.width / 2;
                const playerCenterY = player.y + player.height / 2;
                const obsCenterX = obs.x + obs.width / 2;
                const obsCenterY = obs.y + obs.height / 2;
                const distanceX = Math.abs(playerCenterX - obsCenterX);
                const distanceY = Math.abs(playerCenterY - obsCenterY);

                if (distanceX < (player.width / 2 + obs.width / 2) && distanceY < (player.height / 2 + obs.height / 2)) {
                    collisionOccurred = true;
                    obstacles.splice(index, 1);
                }
            });

            if (collisionOccurred) {
                lives--;
                updateLivesDisplay();
                if (lives <= 0) {
                    isGameOver = true;
                }
            }
        }

        function gameLoop() {
            if (isGameOver) {
                endGame();
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            player.x += dx;
            player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
            updateObstacles();
            checkCollision();

            drawPlayer();
            drawObstacles();

            requestAnimationFrame(gameLoop);
        }

        function endGame() {
            clearInterval(obstacleInterval);
            clearInterval(timerInterval);
            gameOverScreen.style.display = 'flex';
            finalTimeDisplay.textContent = `${Math.floor(gameTime)}s`;
        }
        
        window.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') dx = -player.speed;
            if (e.key === 'ArrowRight') dx = player.speed;
        });

        window.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') dx = 0;
        });

        canvas.addEventListener('touchstart', (e) => {
            const touchX = e.touches[0].clientX - canvas.getBoundingClientRect().left;
            dx = (touchX < canvas.width / 2) ? -player.speed : player.speed;
        });

        canvas.addEventListener('touchend', () => {
            dx = 0;
        });

        restartButton.addEventListener('click', resetGame);
        
        resetGame();

    </script>
</body>
</html>